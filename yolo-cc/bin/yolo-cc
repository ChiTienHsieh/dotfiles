#!/usr/bin/env bash
#
# yolo-cc - Run Claude Code in isolated container
#
# Usage:
#   yolo-cc "your prompt here"
#   yolo-cc --uv "create a FastAPI server"
#   yolo-cc -w /path/to/project "refactor this"
#
# Flags:
#   --uv          Include Python (uv) environment
#   --npm         Include Node.js (npm) environment [TODO]
#   --playwright  Include Playwright for browser automation [TODO]
#   -w, --workspace PATH  Specify workspace directory (default: current dir)
#   --build       Force rebuild images before running
#   --shell       Open interactive shell instead of running claude
#   -h, --help    Show this help message

set -e

# ============ Config ============

# Resolve symlinks to get the actual script location (works on vanilla macOS)
resolve_symlink() {
    local path="$1"
    while [ -L "$path" ]; do
        local dir="$(dirname "$path")"
        path="$(readlink "$path")"
        # Handle relative symlinks
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$path"
}

SCRIPT_PATH="$(resolve_symlink "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
YOLO_CC_DIR="$(dirname "$SCRIPT_DIR")"
COMPOSE_DIR="$YOLO_CC_DIR/compose"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ============ Helpers ============

log_info() { echo -e "${BLUE}[yolo-cc]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[yolo-cc]${NC} $1" >&2; }
log_error() { echo -e "${RED}[yolo-cc]${NC} $1" >&2; }
log_success() { echo -e "${GREEN}[yolo-cc]${NC} $1" >&2; }

truncate_prompt() {
    local prompt="$1"
    local max_len="${2:-50}"
    if [ ${#prompt} -gt $max_len ]; then
        echo "${prompt:0:$max_len}... [truncated, see log file]"
    else
        echo "$prompt"
    fi
}

show_help() {
    cat << 'EOF'
yolo-cc - Run Claude Code in isolated container

Usage:
  yolo-cc [flags] "your prompt"

Flags:
  --uv              Include Python (uv) environment
  --npm             Include Node.js (npm) environment [TODO]
  --playwright      Include Playwright [TODO]
  -w, --workspace   Workspace directory (default: current dir)
  --build           Force rebuild images
  --shell           Open interactive shell (no prompt needed)
  -h, --help        Show this help

Examples:
  yolo-cc "fix all TypeScript errors"
  yolo-cc --uv "create a FastAPI server with SQLAlchemy"
  yolo-cc -w ~/projects/myapp "refactor the auth module"
  yolo-cc --shell                    # Debug: open shell in container

Security:
  - OAuth token passed via env var (not persisted in container)
  - .git is mounted read-only (always recoverable)
  - Container can access internet
  - Token can be revoked at claude.ai/settings if compromised
EOF
}

# ============ Parse Args ============

PROFILES=()
WORKSPACE="$(pwd)"
BUILD_FLAG=""
PROMPT=""
SHELL_MODE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --uv)
            PROFILES+=("uv")
            shift
            ;;
        --npm)
            PROFILES+=("npm")
            shift
            ;;
        --playwright)
            PROFILES+=("playwright")
            shift
            ;;
        -w|--workspace)
            WORKSPACE="$2"
            shift 2
            ;;
        --build)
            BUILD_FLAG="--build"
            shift
            ;;
        --shell)
            SHELL_MODE=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            log_error "Unknown flag: $1"
            show_help
            exit 1
            ;;
        *)
            # Remaining args are the prompt
            PROMPT="$*"
            break
            ;;
    esac
done

# ============ Validation ============

if [ -z "$PROMPT" ] && [ "$SHELL_MODE" = false ]; then
    log_error "No prompt provided"
    show_help
    exit 1
fi

if [ -z "$CLAUDE_CODE_OAUTH_TOKEN" ]; then
    log_error "CLAUDE_CODE_OAUTH_TOKEN not set"
    echo "Please set your Claude Code OAuth token:" >&2
    echo "  export CLAUDE_CODE_OAUTH_TOKEN='your-token'" >&2
    echo "" >&2
    echo "Get your token with: claude setup-token" >&2
    exit 1
fi

if [ ! -d "$WORKSPACE" ]; then
    log_error "Workspace directory not found: $WORKSPACE"
    exit 1
fi

# Convert to absolute path
WORKSPACE="$(cd "$WORKSPACE" && pwd)"

# Check for .git (required for recovery)
if [ ! -d "$WORKSPACE/.git" ]; then
    log_error "No .git directory found"
    echo "" >&2
    echo "YOLO mode requires git for recovery. Initialize with:" >&2
    echo "  cd $WORKSPACE" >&2
    echo "  git init && git add -A && git commit -m 'init before yolo-cc'" >&2
    exit 1
fi

# Check docker
if ! command -v docker &> /dev/null; then
    log_error "docker not found"
    exit 1
fi

if ! docker info &> /dev/null; then
    log_error "Docker daemon not running (is OrbStack running?)"
    exit 1
fi

# ============ Setup Logging ============

# Create logs directory
mkdir -p "$WORKSPACE/logs"

# Ensure logs/ is in .gitignore
GITIGNORE="$WORKSPACE/.gitignore"
if [ ! -f "$GITIGNORE" ] || ! grep -q "^logs/$" "$GITIGNORE"; then
    echo "logs/" >> "$GITIGNORE"
fi

# Create log file with timestamp
TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
LOG_FILE="$WORKSPACE/logs/yolo-cc-$TIMESTAMP.log"

# Write detailed info to log file
{
    echo "========================================"
    echo "yolo-cc session: $TIMESTAMP"
    echo "========================================"
    echo ""
    echo "Workspace: $WORKSPACE"
    echo "Service: ${PROFILES[*]:-base}"
    echo "Mode: $([ "$SHELL_MODE" = true ] && echo "shell" || echo "prompt")"
    echo "Started: $(date)"
    if [ "$SHELL_MODE" = false ]; then
        echo ""
        echo "Full prompt:"
        echo "----------------------------------------"
        echo "$PROMPT"
        echo "----------------------------------------"
    fi
    echo ""
} > "$LOG_FILE"

# ============ Build Profile Args ============

PROFILE_ARGS=""
SERVICE="base"

for profile in "${PROFILES[@]}"; do
    PROFILE_ARGS="$PROFILE_ARGS --profile $profile"
    SERVICE="$profile"  # Use the last profile as service name
done

# ============ Run Container ============

log_info "Workspace: $WORKSPACE"
log_info "Service: $SERVICE"
if [ "$SHELL_MODE" = true ]; then
    log_info "Mode: interactive shell"
else
    log_info "Prompt: $(truncate_prompt "$PROMPT")"
fi
log_info "Log: $LOG_FILE"
echo "" >&2

if [ "$SHELL_MODE" = false ]; then
    echo "================================================================" >&2
    echo -e "${RED}  YOLO MODE: Claude will execute autonomously${NC}" >&2
    echo -e "${GREEN}  Recovery: git checkout . && git clean -fd${NC}" >&2
    echo "================================================================" >&2
    echo "" >&2
fi

cd "$COMPOSE_DIR"

# Export for docker-compose
export WORKSPACE
export CLAUDE_CODE_OAUTH_TOKEN

# Build if needed
if [ -n "$BUILD_FLAG" ]; then
    log_info "Building images..."
    docker compose $PROFILE_ARGS build
fi

# Determine container command
if [ "$SHELL_MODE" = true ]; then
    CONTAINER_CMD="bash"
else
    CONTAINER_CMD="claude -p \"$PROMPT\" --dangerously-skip-permissions --output-format text"
fi

if [ "$SHELL_MODE" = true ]; then
    # Shell mode: use detached + attach for interactive TTY
    CONTAINER_ID=$(docker compose $PROFILE_ARGS run -d "$SERVICE" bash)

    log_info "Container: ${CONTAINER_ID:0:12}"
    echo "Container ID: $CONTAINER_ID" >> "$LOG_FILE"
    echo "" >&2
    log_info "To exec: docker exec -it ${CONTAINER_ID:0:12} bash"
    echo "" >&2

    set +e
    docker attach "$CONTAINER_ID"
    set -e

    # Wait and cleanup
    docker wait "$CONTAINER_ID" > /dev/null 2>&1 || true
    EXIT_CODE=$(docker inspect "$CONTAINER_ID" --format='{{.State.ExitCode}}' 2>/dev/null || echo "0")
    docker rm "$CONTAINER_ID" > /dev/null 2>&1 || true
else
    # Prompt mode: run with output capture
    {
        echo ""
        echo "========================================"
        echo "Container output:"
        echo "========================================"
    } >> "$LOG_FILE"

    set +e
    # -T disables pseudo-TTY for better output capture
    docker compose $PROFILE_ARGS run -T --rm "$SERVICE" \
        bash -c "$CONTAINER_CMD" 2>&1 | tee -a "$LOG_FILE"
    EXIT_CODE=${PIPESTATUS[0]}
    set -e
fi

# ============ Summary ============

echo "" >&2
log_info "Exit code: $EXIT_CODE"

# Log summary to file
{
    echo ""
    echo "========================================"
    echo "Session ended: $(date)"
    echo "Exit code: $EXIT_CODE"
    echo "========================================"
    echo ""
    echo "Git status:"
    cd "$WORKSPACE"
    git status --short 2>/dev/null || echo "(no changes)"
} >> "$LOG_FILE"

# Minimal stdout summary
echo "" >&2
log_info "Log: $LOG_FILE"
log_info "Recovery: git checkout . && git clean -fd"

exit $EXIT_CODE
