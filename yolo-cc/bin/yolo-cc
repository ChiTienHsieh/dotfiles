#!/usr/bin/env bash
#
# yolo-cc - Run Claude Code in isolated container
#
# Usage:
#   yolo-cc "your prompt here"
#   yolo-cc --uv "create a FastAPI server"
#   yolo-cc -w /path/to/project "refactor this"
#
# Flags:
#   --uv          Include Python (uv) environment
#   --npm         Include Node.js (npm) environment [TODO]
#   --playwright  Include Playwright for browser automation [TODO]
#   -w, --workspace PATH  Specify workspace directory (default: current dir)
#   --build       Force rebuild images before running
#   --shell       Open interactive shell instead of running claude
#   --ralph       Enable Ralph loop mode (iterative execution)
#   --max-iterations N    Max iterations for ralph mode (default: 10)
#   --completion-promise TEXT  Promise phrase to signal completion
#   -h, --help    Show this help message

set -e

# ============ Config ============

# Resolve symlinks to get the actual script location (works on vanilla macOS)
resolve_symlink() {
    local path="$1"
    while [ -L "$path" ]; do
        local dir="$(dirname "$path")"
        path="$(readlink "$path")"
        # Handle relative symlinks
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$path"
}

SCRIPT_PATH="$(resolve_symlink "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
YOLO_CC_DIR="$(dirname "$SCRIPT_DIR")"
COMPOSE_DIR="$YOLO_CC_DIR/compose"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ============ Helpers ============

log_info() { echo -e "${BLUE}[yolo-cc]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[yolo-cc]${NC} $1" >&2; }
log_error() { echo -e "${RED}[yolo-cc]${NC} $1" >&2; }
log_success() { echo -e "${GREEN}[yolo-cc]${NC} $1" >&2; }

truncate_prompt() {
    local prompt="$1"
    local max_len="${2:-50}"
    if [ ${#prompt} -gt $max_len ]; then
        echo "${prompt:0:$max_len}... [truncated, see log file]"
    else
        echo "$prompt"
    fi
}

show_help() {
    cat << 'EOF'
yolo-cc - Run Claude Code in isolated container

Usage:
  yolo-cc [flags] "your prompt"

Flags:
  --uv                    Include Python (uv) environment
  --npm                   Include Node.js (npm) environment [TODO]
  --playwright            Include Playwright [TODO]
  -w, --workspace         Workspace directory (default: current dir)
  --build                 Force rebuild images
  --shell                 Open interactive shell (no prompt needed)
  -h, --help              Show this help

Ralph Mode (iterative execution):
  --ralph                 Enable Ralph loop mode
  --max-iterations N      Max iterations (default: 10)
  --completion-promise T  Promise phrase to signal completion

Examples:
  yolo-cc "fix all TypeScript errors"
  yolo-cc --uv "create a FastAPI server with SQLAlchemy"
  yolo-cc -w ~/projects/myapp "refactor the auth module"
  yolo-cc --shell                    # Debug: open shell in container

  # Ralph mode - iterative execution
  yolo-cc --ralph "fix all type errors" --completion-promise "ALL ERRORS FIXED"
  yolo-cc --ralph --max-iterations 20 "improve test coverage to 80%"

Security:
  - OAuth token passed via env var (not persisted in container)
  - .git is mounted read-only (always recoverable)
  - Container can access internet
  - Token can be revoked at claude.ai/settings if compromised
EOF
}

# ============ Parse Args ============

PROFILES=()
WORKSPACE="$(pwd)"
BUILD_FLAG=""
PROMPT=""
SHELL_MODE=false
RALPH_MODE=false
MAX_ITERATIONS=10
COMPLETION_PROMISE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --uv)
            PROFILES+=("uv")
            shift
            ;;
        --npm)
            PROFILES+=("npm")
            shift
            ;;
        --playwright)
            PROFILES+=("playwright")
            shift
            ;;
        -w|--workspace)
            WORKSPACE="$2"
            shift 2
            ;;
        --build)
            BUILD_FLAG="--build"
            shift
            ;;
        --shell)
            SHELL_MODE=true
            shift
            ;;
        --ralph)
            RALPH_MODE=true
            shift
            ;;
        --max-iterations)
            MAX_ITERATIONS="$2"
            shift 2
            ;;
        --completion-promise)
            COMPLETION_PROMISE="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            log_error "Unknown flag: $1"
            show_help
            exit 1
            ;;
        *)
            # Remaining args are the prompt
            PROMPT="$*"
            break
            ;;
    esac
done

# ============ Validation ============

if [ -z "$PROMPT" ] && [ "$SHELL_MODE" = false ]; then
    log_error "No prompt provided"
    show_help
    exit 1
fi

if [ -z "$CLAUDE_CODE_OAUTH_TOKEN" ]; then
    log_error "CLAUDE_CODE_OAUTH_TOKEN not set"
    echo "Please set your Claude Code OAuth token:" >&2
    echo "  export CLAUDE_CODE_OAUTH_TOKEN='your-token'" >&2
    echo "" >&2
    echo "Get your token with: claude setup-token" >&2
    exit 1
fi

if [ ! -d "$WORKSPACE" ]; then
    log_error "Workspace directory not found: $WORKSPACE"
    exit 1
fi

# Convert to absolute path
WORKSPACE="$(cd "$WORKSPACE" && pwd)"

# Check for .git (required for recovery)
if [ ! -d "$WORKSPACE/.git" ]; then
    log_error "No .git directory found"
    echo "" >&2
    echo "YOLO mode requires git for recovery. Initialize with:" >&2
    echo "  cd $WORKSPACE" >&2
    echo "  git init && git add -A && git commit -m 'init before yolo-cc'" >&2
    exit 1
fi

# Check docker
if ! command -v docker &> /dev/null; then
    log_error "docker not found"
    exit 1
fi

if ! docker info &> /dev/null; then
    log_error "Docker daemon not running (is OrbStack running?)"
    exit 1
fi

# ============ Setup Logging ============

# Create logs directory
mkdir -p "$WORKSPACE/logs"

# Ensure logs/ is in .gitignore
GITIGNORE="$WORKSPACE/.gitignore"
if [ ! -f "$GITIGNORE" ] || ! grep -q "^logs/$" "$GITIGNORE"; then
    echo "logs/" >> "$GITIGNORE"
fi

# Create log file with timestamp
TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
LOG_FILE="$WORKSPACE/logs/yolo-cc-$TIMESTAMP.log"

# Determine mode string
if [ "$SHELL_MODE" = true ]; then
    MODE_STR="shell"
elif [ "$RALPH_MODE" = true ]; then
    MODE_STR="ralph (max: $MAX_ITERATIONS)"
else
    MODE_STR="single"
fi

# Write detailed info to log file
{
    echo "========================================"
    echo "yolo-cc session: $TIMESTAMP"
    echo "========================================"
    echo ""
    echo "Workspace: $WORKSPACE"
    echo "Service: ${PROFILES[*]:-base}"
    echo "Mode: $MODE_STR"
    if [ "$RALPH_MODE" = true ]; then
        echo "Max iterations: $MAX_ITERATIONS"
        echo "Completion promise: ${COMPLETION_PROMISE:-none}"
    fi
    echo "Started: $(date)"
    if [ "$SHELL_MODE" = false ]; then
        echo ""
        echo "Full prompt:"
        echo "----------------------------------------"
        echo "$PROMPT"
        echo "----------------------------------------"
    fi
    echo ""
} > "$LOG_FILE"

# ============ Build Profile Args ============

PROFILE_ARGS=""
SERVICE="base"

for profile in "${PROFILES[@]}"; do
    PROFILE_ARGS="$PROFILE_ARGS --profile $profile"
    SERVICE="$profile"  # Use the last profile as service name
done

# ============ Run Container ============

log_info "Workspace: $WORKSPACE"
log_info "Service: $SERVICE"
if [ "$SHELL_MODE" = true ]; then
    log_info "Mode: interactive shell"
elif [ "$RALPH_MODE" = true ]; then
    log_info "Mode: ralph loop"
    log_info "Max iterations: $MAX_ITERATIONS"
    if [ -n "$COMPLETION_PROMISE" ]; then
        log_info "Completion promise: $COMPLETION_PROMISE"
    fi
else
    log_info "Prompt: $(truncate_prompt "$PROMPT")"
fi
log_info "Log: $LOG_FILE"
echo "" >&2

if [ "$SHELL_MODE" = false ]; then
    if [ "$RALPH_MODE" = true ]; then
        echo "================================================================" >&2
        echo -e "${RED}  RALPH MODE: Iterative autonomous execution${NC}" >&2
        echo -e "${YELLOW}  Max iterations: $MAX_ITERATIONS${NC}" >&2
        echo -e "${GREEN}  Recovery: git checkout . && git clean -fd${NC}" >&2
        echo "================================================================" >&2
    else
        echo "================================================================" >&2
        echo -e "${RED}  YOLO MODE: Claude will execute autonomously${NC}" >&2
        echo -e "${GREEN}  Recovery: git checkout . && git clean -fd${NC}" >&2
        echo "================================================================" >&2
    fi
    echo "" >&2
fi

cd "$COMPOSE_DIR"

# Export for docker-compose
export WORKSPACE
export CLAUDE_CODE_OAUTH_TOKEN

# Build if needed
if [ -n "$BUILD_FLAG" ]; then
    log_info "Building images..."
    docker compose $PROFILE_ARGS build
fi

# Determine container command
if [ "$SHELL_MODE" = true ]; then
    CONTAINER_CMD="bash"
elif [ "$RALPH_MODE" = true ]; then
    # Generate ralph loop script to run inside container
    # Escape special characters in prompt and promise for safe embedding
    ESCAPED_PROMPT=$(printf '%s' "$PROMPT" | sed "s/'/'\\\\''/g")
    ESCAPED_PROMISE=$(printf '%s' "$COMPLETION_PROMISE" | sed "s/'/'\\\\''/g")

    CONTAINER_CMD="bash -c '
MAX_ITER=$MAX_ITERATIONS
PROMISE=\"$ESCAPED_PROMISE\"
PROMPT=\"$ESCAPED_PROMPT\"

# Add promise instruction if set
if [ -n \"\$PROMISE\" ]; then
    FULL_PROMPT=\"\$PROMPT

To signal completion, you MUST output exactly: <promise>\$PROMISE</promise>
ONLY output this when the statement is completely TRUE. Do NOT lie to exit.\"
else
    FULL_PROMPT=\"\$PROMPT\"
fi

echo \"ðŸ”„ Ralph loop starting (max: \$MAX_ITER iterations)\" >&2
echo \"\" >&2

for i in \$(seq 1 \$MAX_ITER); do
    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\" >&2
    echo \"ðŸ”„ Ralph iteration \$i/\$MAX_ITER\" >&2
    echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\" >&2

    # Create temp file to capture output while still displaying it
    TEMP_OUTPUT=\"/tmp/ralph-output-\$\$\"

    if [ \$i -eq 1 ]; then
        # First iteration: use -p flag
        claude -p \"\$FULL_PROMPT\" --dangerously-skip-permissions --output-format text 2>&1 | tee \"\$TEMP_OUTPUT\"
    else
        # Subsequent iterations: use --continue with stdin
        echo \"\$FULL_PROMPT\" | claude --continue --dangerously-skip-permissions --output-format text 2>&1 | tee \"\$TEMP_OUTPUT\"
    fi

    # Check for completion promise
    if [ -n \"\$PROMISE\" ]; then
        if grep -q \"<promise>\$PROMISE</promise>\" \"\$TEMP_OUTPUT\" 2>/dev/null; then
            echo \"\" >&2
            echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\" >&2
            echo \"âœ… Completion promise detected!\" >&2
            echo \"   <promise>\$PROMISE</promise>\" >&2
            echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\" >&2
            rm -f \"\$TEMP_OUTPUT\"
            exit 0
        fi
    fi

    rm -f \"\$TEMP_OUTPUT\"

    if [ \$i -lt \$MAX_ITER ]; then
        echo \"\" >&2
        echo \"â³ No promise detected, continuing...\" >&2
        echo \"\" >&2
    fi
done

echo \"\" >&2
echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\" >&2
echo \"ðŸ›‘ Max iterations (\$MAX_ITER) reached\" >&2
echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\" >&2
'"
else
    CONTAINER_CMD="claude -p \"$PROMPT\" --dangerously-skip-permissions --output-format text"
fi

if [ "$SHELL_MODE" = true ]; then
    # Shell mode: use detached + attach for interactive TTY
    CONTAINER_ID=$(docker compose $PROFILE_ARGS run -d "$SERVICE" bash)

    log_info "Container: ${CONTAINER_ID:0:12}"
    echo "Container ID: $CONTAINER_ID" >> "$LOG_FILE"
    echo "" >&2
    log_info "To exec: docker exec -it ${CONTAINER_ID:0:12} bash"
    echo "" >&2

    set +e
    docker attach "$CONTAINER_ID"
    set -e

    # Wait and cleanup
    docker wait "$CONTAINER_ID" > /dev/null 2>&1 || true
    EXIT_CODE=$(docker inspect "$CONTAINER_ID" --format='{{.State.ExitCode}}' 2>/dev/null || echo "0")
    docker rm "$CONTAINER_ID" > /dev/null 2>&1 || true
else
    # Prompt mode: run with output capture
    {
        echo ""
        echo "========================================"
        echo "Container output:"
        echo "========================================"
    } >> "$LOG_FILE"

    set +e
    # -T disables pseudo-TTY for better output capture
    docker compose $PROFILE_ARGS run -T --rm "$SERVICE" \
        bash -c "$CONTAINER_CMD" 2>&1 | tee -a "$LOG_FILE"
    EXIT_CODE=${PIPESTATUS[0]}
    set -e
fi

# ============ Summary ============

echo "" >&2
log_info "Exit code: $EXIT_CODE"

# Log summary to file
{
    echo ""
    echo "========================================"
    echo "Session ended: $(date)"
    echo "Exit code: $EXIT_CODE"
    echo "========================================"
    echo ""
    echo "Git status:"
    cd "$WORKSPACE"
    git status --short 2>/dev/null || echo "(no changes)"
} >> "$LOG_FILE"

# Minimal stdout summary
echo "" >&2
log_info "Log: $LOG_FILE"
log_info "Recovery: git checkout . && git clean -fd"

exit $EXIT_CODE
