#!/usr/bin/env bash
# =============================================================================
# .aliases - Portable aliases and functions for any Unix system
# =============================================================================
# Machine-specific aliases (cd shortcuts, project paths) should go in
# ~/.aliases.local which is NOT tracked in dotfiles.

# -----------------------------------------------------------------------------
# Navigation
# -----------------------------------------------------------------------------
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias downloads="cd ~/Downloads"
alias desktop="cd ~/Desktop"

# -----------------------------------------------------------------------------
# File listing (with colors!)
# -----------------------------------------------------------------------------
alias ls='ls --color=auto'              # Colorize ls (dirs=blue, etc.)
alias ll='ls -lGtr --color=auto'        # Long list, newest last
alias d="du -d1 -h | sort -h"           # Directory sizes, sorted
alias lsh="ls -hl | sort -h"            # Files by size
alias lsl="ls -lt"                      # Files by time (newest first)
alias lsa="ls -a"                       # Show hidden files
alias lla="ls -lGtra --color=auto"      # All files, detailed

# -----------------------------------------------------------------------------
# Utilities
# -----------------------------------------------------------------------------
alias vi="nvim"
alias tree="tree -I '__pycache__|*.pyc|node_modules|.git'"
alias search="find . -name"
alias rlp="realpath"
alias t="type"                          # Check what a command is

# macOS specific
alias pbc="pbcopy"                      # Copy to clipboard
Textedit() { open -e "$@"; }            # Open in TextEdit

# -----------------------------------------------------------------------------
# File operations
# -----------------------------------------------------------------------------
# Move to Trash with timestamp suffix (prevents collision)
# Use -f to force trash files >5MB
trash() {
    local force=false
    local max_size_kb=5120  # 5MB in KB

    # Check for -f flag
    if [[ "$1" == "-f" ]]; then
        force=true
        shift
    fi

    local ts=$(date +"%y%m%d-%H%M%S")
    for f in "$@"; do
        if [[ ! -e "$f" ]]; then
            echo "trash: '$f' not found"
            continue
        fi

        # Get size in KB (works for both files and dirs)
        local size_kb=$(du -sk "$f" 2>/dev/null | cut -f1)

        if [[ "$force" == false && "$size_kb" -gt "$max_size_kb" ]]; then
            local size_mb=$((size_kb / 1024))
            echo "trash: '$f' is ${size_mb}MB (>5MB). Use 'trash -f $f' to force."
            continue
        fi

        local base=$(basename "$f")
        mv -fv "$f" ~/.Trash/"${base}.${ts}"
    done
}
bak() { cp -vr "$@" ".${@}.bak"; }      # Create backup with .bak suffix
hide() { mv -v "$@" ".${@}"; }          # Hide file (prepend dot)

# Find large files
Find_files_bigger_than() {
    local size="$1"
    find . -type f -size "+${size}M" 2>/dev/null
}

# -----------------------------------------------------------------------------
# Config file shortcuts
# -----------------------------------------------------------------------------
# Shell config shortcuts (zsh)
alias zrc="vi ~/.zshrc"                 # Edit zshrc
alias vizsh="vi ~/.zshrc"               # Alias for zrc
alias viali="vi ~/.aliases"             # Edit aliases
alias srzsh="source ~/.zshrc"
alias src="source ~/.zshrc"             # Shorter version
alias vimrc="vi ~/.config/nvim/init.lua"

# Legacy bash config (kept for reference, not actively used)
alias barc="vi ~/.bashrc"               # Edit bashrc
alias viprofile="vi ~/.bash_profile"
alias prompt="vi ~/.bash_prompt"

# -----------------------------------------------------------------------------
# Smart alias creator with conflict detection and AI suggestions
# -----------------------------------------------------------------------------
# Requires: OPENAI_API_KEY in environment

check_name_conflict() {
    local name="$1"
    if type "$name" >/dev/null 2>&1 || alias "$name" >/dev/null 2>&1; then
        return 0  # Conflict exists
    fi
    return 1  # No conflict
}

suggest_alternative_name() {
    local original_name="$1"
    local conflicted_names="$2"

    if [ -z "$OPENAI_API_KEY" ]; then
        echo ""
        return 1
    fi

    local prompt="I want to create a bash alias named '$original_name' but it conflicts with existing commands. These names are already taken: $conflicted_names. Please suggest 1 short alternative name (preferably 2-4 characters) that would be similar but not conflict. Reply with just the suggested name, nothing else."

    local suggestion=$(curl -s -X POST \
        "https://api.openai.com/v1/responses" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "{
            \"model\": \"gpt-4.1-nano-2025-04-14\",
            \"input\": \"$prompt\"
        }" | jq -r '.output[0].content[0].text' 2>/dev/null || echo "")

    suggestion=$(echo "$suggestion" | xargs)
    echo "$suggestion"
}

addali() {
    local alias_name=""
    local conflicted_names=""
    local llm_calls=0
    local max_llm_calls=5

    read "alias_name?Enter the alias name: "

    if [ -z "$alias_name" ]; then
        echo "Alias name cannot be empty!"
        return 1
    fi

    local original_name="$alias_name"
    conflicted_names="$alias_name"

    while check_name_conflict "$alias_name"; do
        echo "(・_・;) '$alias_name' conflicts"

        if [ $llm_calls -ge $max_llm_calls ]; then
            echo "(╯°□°)╯ Max LLM calls reached"
            read "alias_name?Enter name: "
            [ -z "$alias_name" ] && return 1
            continue
        fi

        echo "(°ロ°) Asking OpenAI..."
        suggested_name=$(suggest_alternative_name "$original_name" "$conflicted_names")
        llm_calls=$((llm_calls + 1))

        if [ -z "$suggested_name" ]; then
            echo "(´・ω・\`) AI failed"
            read "alias_name?Enter name: "
        else
            echo "(°▽°) Suggestion: '$suggested_name'"
            read "choice?Accept? (y/n/manual): "
            case $choice in
                y|Y) alias_name="$suggested_name" ;;
                n|N) conflicted_names="$conflicted_names, $alias_name"; continue ;;
                *)   read "alias_name?Enter your preferred name: " ;;
            esac
        fi

        conflicted_names="$conflicted_names, $alias_name"
    done

    echo "(・∀・) '$alias_name' available"

    read "alias_command?Enter the command to alias: "
    [ -z "$alias_command" ] && echo "Command cannot be empty!" && return 1

    alias_command_escaped=$(echo "$alias_command" | sed "s/'/'\\\\''/g")
    full_alias="alias $alias_name='$alias_command_escaped'"

    echo "$full_alias" >> ~/.aliases.local
    eval "$full_alias"

    echo "(ﾉ◕ヮ◕)ﾉ $alias_name → $alias_command"

    source ~/.aliases.local 2>/dev/null
}

# addcd - Quick cd shortcut creator (simpler than addali)
# Usage: navigate to a directory, run `addcd`, enter alias name
addcd() {
    local current_dir="$(pwd)"

    read "alias_name?Alias name to cd here ($current_dir): "

    if [ -z "$alias_name" ]; then
        echo "(´・ω・\`) Name required"
        return 1
    fi

    # Check for conflicts
    if check_name_conflict "$alias_name"; then
        echo "(・_・;) '$alias_name' exists: $(type "$alias_name" 2>&1 | head -1)"
        read "alias_name?Different name: "
        [ -z "$alias_name" ] && return 1

        if check_name_conflict "$alias_name"; then
            echo "(╯°□°)╯ '$alias_name' also taken"
            return 1
        fi
    fi

    local full_alias="alias $alias_name='cd $current_dir'"

    echo "$full_alias" >> ~/.aliases.local
    eval "$full_alias"

    echo "(ﾉ◕ヮ◕)ﾉ $alias_name → $current_dir"
}

# -----------------------------------------------------------------------------
# Prompt drafting
# -----------------------------------------------------------------------------
# p - Quick prompt drafting in nvim
#   p          → new file: /tmp/prompts/prompt-YYMMDD-HHMMSS.md
#   p -c       → continue editing the latest prompt file
#   p --continue
p() {
    local prompts_dir="/tmp/prompts"
    mkdir -p "$prompts_dir"

    if [[ "$1" == "-c" || "$1" == "--continue" ]]; then
        # Find the latest prompt file
        local latest=$(ls -t "$prompts_dir"/prompt-*.md 2>/dev/null | head -1)
        if [[ -z "$latest" ]]; then
            echo "No existing prompt files found in $prompts_dir"
            return 1
        fi
        nvim "$latest"
    else
        # Create new prompt file with timestamp
        local timestamp=$(date +"%y%m%d-%H%M%S")
        nvim "$prompts_dir/prompt-${timestamp}.md"
    fi
}

# -----------------------------------------------------------------------------
# Claude Code MCP helpers
# -----------------------------------------------------------------------------
cldaddcontext7() {
    echo "(°ロ°) Adding Context7 MCP..."
    claude mcp add context7 -- npx -y @upstash/context7-mcp@latest
    echo "(ﾉ◕ヮ◕)ﾉ Use 'use context7' in prompts"
}

cldaddplaywright() {
    echo "(°ロ°) Adding Playwright MCP..."
    claude mcp add playwright npx @playwright/mcp@latest
    echo "(ﾉ◕ヮ◕)ﾉ Say 'use playwright mcp to open browser'"
}

# -----------------------------------------------------------------------------
# Source machine-specific aliases (not tracked in dotfiles)
# -----------------------------------------------------------------------------
[ -f ~/.aliases.local ] && source ~/.aliases.local
